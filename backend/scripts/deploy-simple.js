import { ethers } from "ethers";
import fs from "fs";
import path from "path";

// Import the compiled contract
const contractArtifact = JSON.parse(
  fs.readFileSync("./artifacts/contracts/AuditLog.sol/AuditLog.json", "utf8"),
);

async function main() {
  console.log("Starting AuditLog contract deployment...");

  // Connect to the local Hardhat node
<<<<<<< HEAD
  const provider = new ethers.JsonRpcProvider("http://127.0.0.1:8545");
=======
  const rpcUrl = process.env.BLOCKCHAIN_RPC_URL || "http://127.0.0.1:8545";
  console.log(`Connecting to blockchain at: ${rpcUrl}`);
  const provider = new ethers.JsonRpcProvider(rpcUrl);
>>>>>>> aa993d87623c12db174e6dc06c2f117717d021f5

  // Use the first account from Hardhat node
  const privateKey =
    "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
  const wallet = new ethers.Wallet(privateKey, provider);

  console.log("Deploying contracts with account:", wallet.address);

  // Check deployer balance
  const balance = await provider.getBalance(wallet.address);
  console.log("Account balance:", ethers.formatEther(balance), "ETH");

  // Create contract factory
  const contractFactory = new ethers.ContractFactory(
    contractArtifact.abi,
    contractArtifact.bytecode,
    wallet,
  );

  // Deploy the contract
  console.log("Deploying AuditLog contract...");
  const auditLog = await contractFactory.deploy();

  // Wait for deployment to complete
  await auditLog.waitForDeployment();
  const contractAddress = await auditLog.getAddress();

  console.log("AuditLog deployed successfully!");
  console.log("Contract address:", contractAddress);
  console.log("Transaction hash:", auditLog.deploymentTransaction().hash);

  // Verify deployment by calling a contract method
  try {
    const totalLogs = await auditLog.totalLogs();
    console.log("Contract verification - Total logs:", totalLogs.toString());

    const contractInfo = await auditLog.getContractInfo();
    console.log("Contract info - Owner:", contractInfo[0]);
    console.log("Contract info - Total logs:", contractInfo[1].toString());
    console.log(
      "Contract info - Total submissions:",
      contractInfo[2].toString(),
    );
  } catch (error) {
    console.error("Contract verification failed:", error.message);
  }

  // Save deployment information
  const deploymentInfo = {
    contractAddress: contractAddress,
    deployerAddress: wallet.address,
    transactionHash: auditLog.deploymentTransaction().hash,
    blockNumber: auditLog.deploymentTransaction().blockNumber,
    deployedAt: new Date().toISOString(),
    network: "localhost",
    chainId: 31337,
  };

  // Create deployment info file
  const deploymentPath = path.join(process.cwd(), "deployment.json");
  fs.writeFileSync(deploymentPath, JSON.stringify(deploymentInfo, null, 2));
  console.log("Deployment info saved to:", deploymentPath);

  // Create environment variable template
  const envTemplate = `
# Blockchain Configuration (Generated by deployment script)
AUDIT_CONTRACT_ADDRESS=${contractAddress}
BLOCKCHAIN_PRIVATE_KEY=${privateKey}
BLOCKCHAIN_RPC_URL=http://127.0.0.1:8545
CHAIN_ID=31337
`;

  const envPath = path.join(process.cwd(), ".env.blockchain");
  fs.writeFileSync(envPath, envTemplate.trim());
  console.log("Environment template saved to:", envPath);

  console.log("\nDeployment completed successfully!");
  console.log("Next steps:");
  console.log("1. Add these variables to your .env file:");
  console.log(`   AUDIT_CONTRACT_ADDRESS=${contractAddress}`);
  console.log(`   BLOCKCHAIN_RPC_URL=http://127.0.0.1:8545`);
  console.log(`   BLOCKCHAIN_PRIVATE_KEY=${privateKey}`);
  console.log("2. Restart your backend server");

  return {
    contractAddress,
    deployerAddress: wallet.address,
    transactionHash: auditLog.deploymentTransaction().hash,
  };
}

// Handle deployment
main()
  .then((result) => {
    console.log("\nDeployment script completed successfully");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\nDeployment failed:", error);
    process.exit(1);
  });
